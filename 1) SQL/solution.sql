CREATE TABLE table_refactored ( 
	CRED_ID INT, 
	DATA DATE, 
	OPER VARCHAR(30), 
  SUMMA INT 
); 



INSERT INTO table_refactored (CRED_ID, DATA, OPER, SUMMA)  
VALUES  
	('1','2020-01-01','Вынос на просрочку','100'),  
	('1','2020-01-06','Вынос на просрочку','20'),  
	('1','2020-01-11','Гашение просрочки','120'),  
	('1','2020-01-16','Вынос на просрочку','100'),  
	('1','2020-01-21','Гашение просрочки','20'),  
	('1','2020-01-26','Гашение просрочки','20'),  
	('1','2020-01-31','Гашение просрочки','20'),  
	('1','2020-02-05','Вынос на просрочку','20'), 
	('1','2020-02-10','Вынос на просрочку','20'), 
	('1','2020-02-15','Гашение просрочки','80'),  
	('2','2020-01-05','Вынос на просрочку','50'), 
	('2','2020-01-10','Вынос на просрочку','10'), 
	('2','2020-01-15','Вынос на просрочку','20'), 
	('2','2020-01-20','Вынос на просрочку','10'), 
	('3','2020-01-01','Вынос на просрочку','60'), 
	('3','2020-01-15','Гашение просрочки','50'),  
	('3','2020-01-29','Вынос на просрочку','15'),  
	('3','2020-02-12','Гашение просрочки','24'); 



SET  
  @cred_id := 0, -- переменная для отслеживания "группы" заёмщика 
  @balance := 0, -- текущий баланс заёмщика 
  @date_begin := "-"; -- дата последнего непогашенного кредита 



WITH 
credit_information AS (
  SELECT
    CRED_ID,
    DATA,
    OPER,
    SUMMA,
    
    CASE -- считаем баланс заёмщика после данной операции
      WHEN CRED_ID <> @cred_id AND OPER = "Вынос на просрочку" THEN @balance := -SUMMA -- начали рассматривать нового заёмщика → баланс равен -сумма_заёма
      WHEN CRED_ID = @cred_id AND OPER = "Вынос на просрочку" THEN @balance := @balance - SUMMA -- заёмщик старый, но кредит новый → добавляем долг
      WHEN CRED_ID = @cred_id AND OPER = "Гашение просрочки" THEN @balance := @balance + SUMMA -- заёмщик старый, перевёл деньги → гасим долг
    END AS balance,
    
    CASE -- дата начала текущего кредита
      WHEN CRED_ID <> @cred_id AND OPER = "Вынос на просрочку" THEN @date_begin := DATA -- начали рассматривать нового заёмщика → запоминаем дату его первого кредитования 
      WHEN CRED_ID = @cred_id AND OPER = "Вынос на просрочку" AND @balance = -SUMMA THEN @date_begin := DATA -- клиент старый, уже гасил просрочку, но решил взять новый кредит → запоминаем новую дату кредитования
      ELSE @date_begin -- для всех остальных строк — просто дублируем данные из последней обработанной строки (они те же, что в переменной), так как они относятся к одному кредитному делу
    END AS DATA_BEGIN,
    
    @cred_id := CRED_ID AS CRED_ID_ -- обновляем следящую за заёмщиком переменную
  FROM table_refactored
),
credit_information_numerated AS (
  SELECT 
    *,
    ROW_NUMBER() OVER (PARTITION BY CRED_ID ORDER BY DATA DESC) AS oper_order -- нумеруем строки по очерёдности операций в порядке уменьшения даты (чтобы можно было легко взять последнюю операцию у заёмщика, она будет под номером 1)
  FROM credit_information
  ORDER BY CRED_ID ASC, DATA ASC -- возвращаем прежний порядок строк
)

SELECT 
  CRED_ID,
  DATA_BEGIN,
  CASE -- в качестве DATA_END используется значение DATA из строки (если кредит закрылся на данной операции) или NULL
    WHEN balance = 0 THEN DATA 
    ELSE NULL
  END AS DATA_END
FROM credit_information_numerated
WHERE 
  balance = 0 -- информация об операциях по полному закрытию кредита
  OR
  oper_order = 1; -- информация о ещё не закрытых кредитах (строки с oper_order = 1 это последняя операция заёмщика)



